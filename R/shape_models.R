# This script was written as a part of springer bookchapter titled 
# "Incorporating sequence-dependent DNA shape and dynamics into 
# transcriptome data analysis"
# 
# 
# This script uses DNA shape profiles generated by dna_shape_analysis.R for 
# modelling the data to develop a classifier between the set of TF regulated 
# promoters and the remaining parameters (others)
# 

library(reshape)
library(ggplot2)
library(tidyverse)
library(cluster)
library(factoextra)
library(gridExtra)
library(monier)
library(randomForest)
library(reprtree)

params<-c("Shear", "Stretch", "Stagger", "Buckle", "PropTw", "Opening", 
          "Shift", "Slide", "Rise", "Tilt", "Roll", "Twist","MGW")
num_datasets<-2
seq_length<-20
nuc_class<-c("A","C","G","T")
data_labels<-c("tf_regulated","others")
shape_data_names<-c("tf_reg_shape","others_shape")
#shape data
tf_reg_shape<-read.table("5bin_dna_shape_tf_reg_uniq",header=T)
others_shape<-read.table("5bin_dna_shape_others_uniq",header=T)

#flatten and vectorize static shape data 
per_sequence_shape<-function(data,seq_length){
   third_pos<-seq(1,dim(data)[1],seq_length-4)
   per_seq_res<-lapply(1:length(third_pos), function(pos){
      one_seq_data<-data[third_pos[pos]:(third_pos[pos]+(seq_length-5)),1:13]
      df<-melt(one_seq_data)
      df[,2]
   })
}
#flatten and vectorize ensemble shape data 
per_sequence_ensemble<-function(data,seq_length){
   third_pos<-seq(1,dim(data)[1],seq_length-4)
   per_seq_res<-lapply(1:length(third_pos), function(pos){
      one_seq_data<-data[third_pos[pos]:(third_pos[pos]+(seq_length-5)),14:78]
      df<-melt(one_seq_data)
      df[,2]
   })
}
# row names
row_names_vec<-function(data,seq_length){
   third_pos<-seq(1,dim(data)[1],seq_length-4)
   per_seq_res<-lapply(1:length(third_pos), function(pos){
      one_seq_data<-data[third_pos[pos]:(third_pos[pos]+(seq_length-5)),1:13]
      strsplit(rownames(one_seq_data)[1],"_")[[1]][1]
   })
}
#static column names
col_n<-c()
for(i in 1:length(params)){
   for(j in 1:(seq_length-4)){
      a_coln<-paste(params[i],"pos",j,sep="_")
      col_n<-c(col_n,a_coln)
   }
}
#ensemble column names
col_n_ens<-c()
for(i in 1:length(params)){
   for(k in 1:5){ #5 bins
      for(j in 1:(seq_length-4)){
         a_coln<-paste(params[i],paste("bin",k,sep=""),"pos",j,sep="_")
         col_n_ens<-c(col_n_ens,a_coln)
      }
   }
}
#use the features data to make test and training datasets
make_test_train_sets<-function(data,train_set_size,label_column,labels){
   df_filtered<-data
   train_size <- train_set_size  # 70% for train, 30% for test
   set.seed(123)
   class_1_data <- subset(df_filtered, get(label_column) == labels[1])
   class_2_data <- subset(df_filtered, get(label_column) == labels[2])
   train_samples_class_1 <- sample(1:nrow(class_1_data),nrow(class_1_data) * train_size)
   train_samples_class_2 <- sample(1:nrow(class_2_data),nrow(class_2_data) * train_size)
   train_data <- rbind(
      class_1_data[train_samples_class_1, ],
      class_2_data[train_samples_class_2, ]
   )
   test_data <- rbind(
      class_1_data[-train_samples_class_1, ],
      class_2_data[-train_samples_class_2, ]
   )
   list(train_data,test_data)
}

# to extract shape parameter measures according to positional binning by a given window size
binning_pos_data_static<-function(data,name_string,window_size,par_col){
   # data is the df of shape profiles
   # name_string is the name to be given to shape profiles for plotting
   # window size is the size of window to take all values at those positions
   # in one bin for a boxplot
   # par_col is the conformational parameter column number
   binned_pos_data<-lapply(1:(seq_length-4),function(x){
      pos_id<-seq(x,dim(data)[1],seq_length-4)
      pos_data<-data[pos_id,par_col]
      pos_data<-cbind(rep(paste("pos",x+2,sep=""),length(pos_data)),as.numeric(pos_data))
      pos_data
   })
   binned_pos_data<-do.call(rbind,binned_pos_data)
   binned_pos_data<-cbind(rep(paste(name_string),dim(binned_pos_data)[1]),binned_pos_data)
   colnames(binned_pos_data)<-c("data","position","value")
   binned_pos_data
}

#flatten the shape features
shape_features<-lapply(1:length(shape_data_names),function(df_id){
   data<-get(shape_data_names[df_id])
   data_per_seq<-per_sequence_shape(data,20)
   data_per_seq<-as.data.frame(do.call(rbind,data_per_seq))
   data_rows<-row_names_vec(data,20)
   colnames(data_per_seq)<-col_n
   rownames(data_per_seq)<-data_rows
   data_per_seq$id<-paste(data_labels[df_id],1:dim(data_per_seq)[1],sep="")
   data_per_seq$label<-rep(paste(data_labels[df_id]),dim(data_per_seq)[1])
   data_per_seq
})
static_data<-as.data.frame(do.call(rbind,shape_features))
write.table(static_data,"static_features")

#flatten the ensemble features
ens_features<-lapply(1:length(shape_data_names),function(df_id){
   data<-get(shape_data_names[df_id])
   data_per_seq<-per_sequence_ensemble(data,20)
   data_per_seq<-as.data.frame(do.call(rbind,data_per_seq))
   data_rows<-row_names_vec(data,20)
   colnames(data_per_seq)<-col_n_ens
   rownames(data_per_seq)<-data_rows
   data_per_seq$id<-paste(data_labels[df_id],1:dim(data_per_seq)[1],sep="")
   data_per_seq$label<-rep(paste(data_labels[df_id]),dim(data_per_seq)[1])
   data_per_seq
})
ens_data<-as.data.frame(do.call(rbind,ens_features))
write.table(ens_data,"ensemble_features")

# static_data<-read.table("static_features",header=T)
# ens_data<-read.table("ensemble_features",header=T)

# MODELLING OF DATA FOR SEQUENCE, STATIC and ENSEMBLE 
set.seed(1234)
shape_test_train<-make_test_train_sets(static_data[,-which(names(static_data)=="id")],
                                       0.7,"label",c("tf_regulated","others"))
ens_test_train<-make_test_train_sets(ens_data[,-which(names(ens_data)=="id")],
                                     0.7,"label",c("tf_regulated","others"))

shape_train<-shape_test_train[[1]]
shape_test<-shape_test_train[[2]]
ens_train<-ens_test_train[[1]]
ens_test<-ens_test_train[[2]]

#RANDOM FOREST MODEL (SHAPE)
rf_model_shape<-randomForest(as.factor(label) ~ ., data = shape_train,ntree=50)
predicted_rf_shape <- predict(rf_model_shape, 
                              newdata = shape_test[,-which(names(shape_test) == "label")],
                              type="class")
reprtree:::plot.getTree(rf_model_shape)
accuracy_rf_shape <- sum(predicted_rf_shape == shape_test[,which(names(shape_test) == "label")])*100/dim(shape_test)[1] 
cat("Accuracy of the Random Forest model:", accuracy_rf_shape, "%\n")

#RANDOM FOREST MODEL (ensemble)
rf_model_ens<-randomForest(as.factor(label) ~ ., data = ens_train,ntree=50)
predicted_rf_ens <- predict(rf_model_ens, 
                            newdata = ens_test[,-which(names(ens_test) == "label")],
                            type="class")
reprtree:::plot.getTree(rf_model_ens)
accuracy_rf_ens <- sum(predicted_rf_ens == ens_test[,which(names(ens_test) == "label")]) * 100/dim(ens_test)[1] 
cat("Accuracy of the Random Forest model:", accuracy_rf_ens, "%\n")

# extract TFs which were in "others" but were classified as 
# "tf regulated" with the shape classifiers and vice versa
# model using STATIC DATA
predict_all_static<-as.data.frame(predict(rf_model_shape,
                            newdata = static_data,
                            type="class"))
shape_ori_predict<-cbind(static_data,predict_all_static)
colnames(shape_ori_predict)<-c(colnames(static_data,),"predict_all_static")
shape_ori_pred_labels<-as.data.frame(paste(shape_ori_predict[,which(names(shape_ori_predict)=="label")],
                             shape_ori_predict[,which(names(shape_ori_predict)=="predict_all_static")],
                             sep=" "))
table(shape_ori_pred_labels)
misclass_static<-shape_ori_predict[shape_ori_predict[,which(names(shape_ori_predict)=="label")] != shape_ori_predict[,which(names(shape_ori_predict)=="predict_all_static")],c(209:211)]

# model using ENSEMBLE DATA
predict_all_ens<-predict(rf_model_ens,
                         newdata = ens_data,
                         type="class")
ens_ori_predict<-cbind(ens_data,predict_all_ens)
colnames(ens_ori_predict)<-c(colnames(ens_data,),"predict_all_ens")

ens_ori_pred_labels<-as.data.frame(paste(ens_ori_predict[,which(names(ens_ori_predict)=="label")],
                                         ens_ori_predict[,which(names(ens_ori_predict)=="predict_all_ens")],
                                         sep=" "))
table(ens_ori_pred_labels)
misclass_ens<-ens_ori_predict[ens_ori_predict[,which(names(ens_ori_predict)=="label")] != ens_ori_predict[,which(names(ens_ori_predict)=="predict_all_ens")],c(1041:1043)]

# find misclassified instances
# find associated genomic regions
misclass_tf_reg_genes_static<-rownames(misclass_static[misclass_static[which(names(misclass_static)=="label")]=="tf_regulated",])
misclass_others_genes_static<-rownames(misclass_static[misclass_static[which(names(misclass_static)=="label")]!="tf_regulated",])
misclass_tf_reg_ens<-rownames(misclass_ens[misclass_ens[which(names(misclass_ens)=="label")]=="tf_regulated",])
misclass_others_ens<-rownames(misclass_ens[misclass_ens[which(names(misclass_ens)=="label")]!="tf_regulated",])

# to extract bed format from row names
options(scipen = 999)
loc_to_bed<-function(list_loc){
   bed_format<-lapply(1:length(list_loc),function(x){
      end<-strsplit(list_loc[x],"-")[[1]][2]
      start<-strsplit(strsplit(list_loc[x],"-")[[1]][1],":")[[1]][2]
      chr<-strsplit(strsplit(strsplit(list_loc[x],"-")[[1]][1],":")[[1]][1],">")[[1]][2]
      c(chr, start, end)
   })
   do.call(rbind,bed_format)
}

bed_misclass_others_ens<-loc_to_bed(misclass_others_ens)
write.table(bed_misclass_others_ens,"misclass_others_ens.bed",sep="\t",
            col.names = F,row.names = F,quote=F)

bed_misclass_others_static<-loc_to_bed(misclass_others_genes_static)
write.table(bed_misclass_others_static,"misclass_others_static.bed",
            sep="\t",col.names = F,row.names = F,quote=F)

bed_misclass_tf_reg_ens<-loc_to_bed(misclass_tf_reg_ens)
write.table(bed_misclass_tf_reg_ens,"misclass_tf_reg_ens.bed",
            sep="\t",col.names = F,row.names = F,quote=F)

bed_misclass_tf_reg_static<-loc_to_bed(misclass_tf_reg_genes_static)
write.table(bed_misclass_tf_reg_static,"misclass_tf_reg_static.bed",
            sep="\t",col.names = F,row.names = F,quote=F)

